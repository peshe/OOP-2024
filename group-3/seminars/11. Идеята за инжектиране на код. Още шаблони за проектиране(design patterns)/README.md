# 11. Идеята за инжектиране на код. Още шаблони за проектиране(design patterns)

Следват поредица от задачи и техните решения, които са свързани и вариация на различни случай за код, който изпълнява плащания. Логиката зад плащането не е важна и е скрита зад функция, която "смята дълго време". Идеята е, че този процес е дълъг и има нужда от информация за своето стартиране и край с цел подобряване на неочаквани грешки (например връзката с приложението, което изпълнява плащания е прекъсната).

Целта е да разгледаме дадени имплементанции и ограниченията и проблемите, които те имат и да видим и въведем идеята за инжектиране на код и как тя ни помага.

## 1. Начало: PaymentProcessor 
Създай клас `PaymentProcessor`, който има метод `ProcessPayment`. Методът трябва да показва съобщения в конзолата при стартиране, приключване и при неочаквани грешки.

## 2. Добавяне на клас Logger
Имплементирай клас `Logger`, който има методи `void Log(const std::string& message)` и `void LogError(const std::string& message)`, който показва съобщението на конзолата. Добавете поле от тип `Logger` в `PaymentProcessor` и го използвайте вместо `std::cout` и `std::cerr`. Изпълнете 10 плащания в `main()`.


## 3. Конфигуриране на Logger

Добавете възможност за конфигуриране на `Logger` чрез неговия конструктор. Да се дава възможност за логване на текущата дата и час при всяко съобщение, както и за променяне на цвета, с който се пише на конзолата. За `cout` възможните цветове да са зелен, син и бял, а за `cerr` червен и бял.


### Проблеми с текущия код
Макар че имаме логър, който може да бъде конфигуриран, не можем да конфигурираме полето `logger` на `PaymentProcessor` по никакъв начин. Можем да направим default constructor за `PaymentProcessor`, който да извиква конструктора на `Logger`, но това също не е достатъчно добро, защото `PaymentProcessor` ще започне да отговаря за 2 неща - плащанията и логъра.

**(Violation 1)** - Класовете `Logger` и `PaymentProcessor` са прекалено свързани(coupling). Промени по `Logger` изискват промени по имплементацията на `PaymentProcessor`. 

### Решение
Искаме да можем да подаваме конфигурация за логъра така че, когато има друга конфигурация, да не трябва да променяме имплементацията на `PaymentProcessor`. Това става с добре познатия ни `constructor`.


С текущата имплементация, всякакви промени по конфигурацията на логъра се случва извън класа `PaymentProcessor`, Независимо дали, добавяме, махаме или променяме стойности, нови конфигурации и т.н.
`PaymentProcessor` не се променя по никакъв начин. Това е знак за по-добър дизайн на класовете ни и връзките между тях.

## 4. Промяна: FileLogger
Имплементирайте нов клас `FileLogger`, който позволява логване във файл. Когато съобщение бъде логнато, то трябва да бъде записвано във файл `logs.txt`. Новият логър да поддържа същата функционалност като предишния `Logger` без цветовете. Използвайте `FileLogger` вместо `Logger` в `PaymentProcessor`.

### Проблеми с текущата имплементация
В предишната задача стигнахме до заключението, че промяната на логъра, не трябва да принуждава `PaymentProcessor` по някакъв начин да си променя имплементацията. Това нарушава принципът на `Single responsibility`, който гласи че **всеки клас трябва да прави 1 нещо и да го прави добре**. 

Сега срещаме същият проблем, но на друго ниво. Досега промени по самият клас `Logger` не ни принуждаваха да променяме `PaymentProcessor`, но сега след като въведохме напълно друг клас за логване във файл, отново сме принудени да променим `PaymentProcessor`, макар че той не би трябвало да се интересува от това дали логваме в конзолата или във файл. Стигаме до същият проблем както преди но на друго ниво.

В случая тази промяна е цялостната смяна на `Logger`. 

**(Violation 1)** - Класовете `Logger` и `PaymentProcessor` са прекалено свързани(coupling). Промени по `Logger` изискват промени по имплементацията на `PaymentProcessor`. 

**NEW (Violation 2)** - Класовете `FileLogger` и `PaymentProcessor` са прекалено свързани(coupling). Смяна на `FileLogger` с друга имплементация води до промени по `PaymentProcessor`.


Нека помислим откакво имаме нужда и какво трябва можем да правим в `PaymentProcessor`, което е свързано с логване. Всъщност единственото нещо, което ни интересува като автори на класа е да можем да логваме информация и да логваме грешки. Нищо друго не ни интересува, дали логваме в конзолата или във файл, дали има час и дата или не, какъв е цвета и т.н. Важно е да можем да логнем дадено съобщение, което ние сме преценили, че трябва да се запази по някакъв начин. 

Преди бяхме свързани с `Logger` и неговата конзолна имплементация. Сега сме свързани с `FileLogger` и неговата имплементация за писане във файл.

### Решение
Да нямаме знания и достъп до никаква имплементация, а по-скоро само и единствено до интерфейс - `LogInfo` и `LogError`.

Това можем да постигнем ако използваме абстрактен базов клас и чисто виртуални методи.

Вече можем да използваме наследяване при логърите и да използваме абстрактния базов клас в `PaymentProcessor`.


Обърнете внимание на изпълнението в `main()`, Вече можем да създаваме `PaymentProcessor` с различни имплементации(в случая `Logger` и `FileLogger`), които изпълняват условията поставени от абстрактният базов клас `ILogger`.

#### Нови проблеми и решения
Решихме проблемите, които предишната ни имплементация имаше. Текущата въвежда повече сложност, както и нуждата от голяма четворка за `PaymentProcessor`, тъй като вече имаме указател като поле. Това означава, 
че също имаме полиморфизъм, тоест имаме нужда от виртуален деструктор на абстрактния базов клас. А за да копираме успешно класовете които го наследяват, имаме нужда от `clone`, тъй като нямаме информация от базовия клас, кой от наследяващите класове е текущия тип. 

## 5. ComplexLogger
Добавете 5 нови функции, които изпълняват плащане. Две от тях да използва конзолния логър, Други две от тях да използва файловия логър, а последната да използва нов клас `ComplexLogger`, който логва едновременно както и във файл-а, така и в конзолата.

Целта на задачата е:
1. Да се види следващото ниво на абстракция, досега разделяхме имплементациите на класовете, нека се опитаме да разделим и създаване им
2. Да се упражни множествено наследяване


Можем да видим как използваме множествено наследяване за `ComplexLogger`.

### Потенциални проблеми
Целта на различните `processN` методи е да покажат, че може на много места да използваме логъри, и то различни, реално се случва да инициализираме дадени данни на десетки или стотици места в нашия код, когато проектите са по-големи. В тези случай бихме изкали да имаме начин за централно създаване и променяне на конфигурацията за подразбиране.

Всеки един от наследяващите класове има свой конструктор, в случая тези конструктори имат стойности по подразбиране за параметрите, но какво ако в нашата система искаме стойностите по подразбиране да са други?

Можем да използваме `factory pattern`, за да създаваме различни логъри:

Логиката за създаване на логери вече е преместена във фабриката за логери. Този вид фабрика (с тези параметри) има смисъл само когато конструкторите на всички класове се припокриват, както е в текущия случай. Ако имаме логер, който изисква параметри, напълно различни от текущите, ще са необходими други подходи. LoggerFactory е наистина полезна, когато не знаем типа на обекта, който ще създаваме по време на компилация, а по-скоро го знаем по време на изпълнение, например когато потребителят го предоставя, когато го четем от файл и т.н.

Все пак, този пример показва как сега можем да променим стойността по подразбиране за логера в цялото приложение на едно място - метода `createLogger`.