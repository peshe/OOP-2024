# Структури. Разположение в паметта. Битови полета. Разделна компилация.

> Колиствените натрупвания водят до качествени изменения.
>
> &mdash; Георг Вилхелм Фридрих Хегел

## Въведение

В началото нещата, за които говорим най-вероятно ще са неясни, моят съвет е все пак да се прочетат, ще правят смисъл в ретроспекция.

Досега, по УП учихме как да създаваме променливи от типовете дадени от самия език.

Фокусът ни от тук нататък е да да използваме тези типове и да ги надградим, като започнем да създаваме наши типове. 
![Alt text](image-1.png)

Чрез добре измислени наши типове, имаме силата да моделираме отделните части на произволно сложен проблем и това как те си взаимодействат.

### Типове данни, дадени от езика

Tиповете данни, дадени от езика, са ни познати. Наричаме ги **primitive data types** и сме създавали не малко променливи с тях:

<small><b>Пример 1: Примитивни типове данни</b></small>

```c++
#include <iostream>

int main() {
    int number = 42; // <-- int
    int numbers[100] = {0}; // <-- array
    char initial = 'A'; // <-- char

    return 0;
}
```

### Типове данни, създадени от нас

Има и друга "категория" типове данни, те са типовете данни, които ние можем да денифинираме. Вече сме виждали енумерациите(`enum`), които спадат в тази категория.

<small><b>Пример 2: Енумерация - дефиниране, инстанциране и сравнение</b></small>

```c++
#include <iostream>

enum DayOfWeek {
	Monday = 0,
	Tuesday = 1,
	Wednesday = 2,
	Thursday = 3,
	Friday = 4,
	Saturday = 5,
	Sunday = 6,

};

int main() {
	DayOfWeek today = Monday; // <-- DayOfWeek, defined by us.

	if (today == Saturday || today == Sunday) {
		std::cout << "It's the weekend!";
	}
	else {
		std::cout << "It's a weekday.";
	}

	return 0;
}

```

<br/>

Структурите (`struct`) които ще разглеждаме по-долу също спадат в тази категория на типове, които ние дефинираме.

---

## Структури

Целта на структурите е да групира концептуално даден набор от данни.

![Alt text](image-3.png)

Досега, ако трябваше по някакъв начин да моделираме точка от двумерното пространство чрез код, бихме направили променливи `pointX` и `pointY`.

Структурите ни позволяват да обединим тези промениви в наш собствен тип, който можем да наречем `Point`, който групира `x` и `y`.

<small><b>Пример 3: Структура - дефиниране, инстанциране и достъп до **полета(fields)** </b></small>

```c++
#include <iostream>

struct Point {
    double x;
    double y;
};

void printPoint(Point p);

int main() {
    Point point = { 3.5, 2.5 };

    printPoint(point);

    return 0;
}

void printPoint(Point p) {
    std::cout << "Point coordinates: (" << p.x << ", " << p.y << ")" << std::endl;
}
```

Дефинираните в `Point`, `x` и `y`, отсега нататък ще наричаме **полета**.

Имайки този нов тип `Point`, вече можем да го използваме като всеки друг тип, например във функцията `printPoint`, той е параметър, в картинката по-долу са показани разликите:
 1. Декларацията на функцията се промени, вместо 2 параметъра `x` и `y`, очаква само един от тип `Point` на име `p`.
 2. Самата имплементация също се променя, за да достъпим стойностите на `x` и `y`, които вече са част от структурата `Point`, трябва да използваме "оператор точка" на самата инстанция `p` --> `p.x`, `p.y`.

![Alt text](image-4.png)

### Дефиниране на структури

TODO: стана сложно, размести.

C++ ни предоставя ключовата дума `struct`, за дефинирането на структури.

Структури обикновено използваме когато има даден набор от променливи, които вървят заедно. В този случай имаме променливите `x` и `y`, които определят къде стои дадена точка в двумерна координатна система.

Повечето действия, които бихме правили с дадена точка включват едновременно и двете координати - намиране на разтояние спрямо друга точка, изчисление, всички тези действие биха използвали и двете променливи `x` и `y`, това означава че винаги когато създаваме такава точка, подаваме я като параметър на фукнция и т.н. трябва да се грижим и за двете променливи.

Използвайски структурата `Point` обедениняваме тези две променливи в една.

#### Сравнение с масив

И двата типа групират друг тип данни, когато създаваме масив, трябва да сме наясно този масив какви данни ще съдържа - `int`, `double`, `bool`, `char` и т.н.

По същия начин, когато създаваме структура, трябва да сме наясно какви данни ще "обвива". Тези данни обаче могат да са различни

##### Цел при използване

Целта на един масив е да групира много данни от един и същи тип

Целта на структурите е да групира данни от различен тип (възможно е и да са от еднакъв), перфектни са за групиране на едно нещо с много различни съставни части - примерно `Person`.

```c++

#include <iostream>

struct Person {
    char firstName[100];
    char lastName[100];
    char address[200];
    int age;
};

int main() {
    Person person;

    strcpy(person.name, "John Doe");
    person.age = 30;
    strcpy(person.address, "123 Main Street, Anytown, Anycountry");

    std::cout << "Name: " << person.name << std::endl
              << "Age: " << person.age << std::endl
              << "Address: " << person.address << std::endl;

    return 0;
}

```

##### В какви случаи са полезни - кога се сещаме да ги използваме

##### Как достъпваме данните, които те групират

елементите на един масив имат последнователност, тях ги достъпваме с оператора скоби `numbers[2]`, или много по-често докато въртим цикли `numbers[i]`.

Тоест, елементите на един масив могат да бъдат достъпени чрез своя индекс в масива, те нямат имена.

Противоположно на масивите, данните в една структура имат имена и ние ги назоваваме в момента на дефинирането на структурата.

Тях ги достъпваме с оператор точка 


ТОDO: пример с 2 структури от един и същи тип и как оператор точка достъпва само полетата на едната структура.
```c++

std::cout << "Name: " << person.name << std::endl
              << "Age: " << person.age << std::endl
              << "Address: " << person.address << std::endl;
```

#### Комбиниране на масив и структура

- масив от структури
- структура с масиви - окей, но без динамична памет
  TODO: Пример за char[] в структура

<small><b>Пример 5: Дефиниране на структура </b></small>

```c++
struct Point {
    double x;
    double y;
};
```

TODO: Кога използваме структури?
TODO: array vs struct
TODO: array of struct
TODO: array of structs with nested structs
TODO: Nesting structures: Triangle -> area, perimeter,

example for showing useful structs -> array of points, function that prints them, function that finds the furthest point from the center
todo: nail & hammer metaphor for oop forward and the modelling part -> read problem statement -> model the problem through user defined types - enum + struct, etc. (no dynamic memory, that's for classes)

todo: modelling part -> bad naming of Point -> Point2D, Point3D

### Въпроси

- Какво са структурите?
- С какво те са полезни?
- Какво е тяхното приложение в практиката?
- въпроси за добри практики

- ** Въпроси, чиито отговори не са в текста по-горе **
- \*\* Задача със структура в структурата

TODO: spell check.
TODO: Добри практики

- дефиниране на структури в отделни файлове, excalidraw this + the include in vs
- 1 file - 1 class, 1 struct - folder structure should convey what the codebase contains clearly. There are cases where you can break this convention, for now follow it.
- define guards for double inclusion

TODO: theory practice questions
TODO: Simple tasks for understanding the syntax

- create struct
- print struct
- create a method inside the struct
- create a function that accepts the struct
- some

TODO: задачи + решения

TODO: Possibly? Show operator overload, first do it with a method add for example. Operator overload for <>?
