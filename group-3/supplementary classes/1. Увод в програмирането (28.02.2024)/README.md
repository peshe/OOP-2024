# Въведение

Целта на допълнителното обучение е да преговорим част от материала по УП и да го надградим с добра представа как той ще изглежда по ООП.

По-голямата част от задачите за взаимствани от публичните материали на Калин Георгиев. Можете да намерите материалите [тук](https://github.com/stranxter/lecture-notes/blob/master/homeworks/Problems%20in%20Programming.pdf);

# Задачи
Надолу има задачи с решение, преди да гледаш решението, пробвай се да решиш задачата сам, само така можем да се научим.

## Подаване по стойност и подаване по референция

- `operator *`
  - като част от тип
  - като част от стойност
- `operator &`
  - като част от тип
  - като част от стойност
- Визуализация
  - паметта
  - стойност на променлива от тип `int`, `char`, `bool`, `char[]`
    - адрес на променливите
  - стойност на променлива от тип `int *`, `char *`, `bool *`
  - адрес на променливите
- **Дереференциране** -> \*p и
  **Референциране** -> &a;

  ```c++
  int main() {
  int a = 10;    // Declare an integer variable a
  int* p = &a;   // Declare a pointer p and initialize it with the address of a

  std::cout << "The value of a through pointer p is: " << *p << std::endl;

  *p = 20;
  std::cout << "The new value of a is: " << a << std::endl;

  return 0;
  }
  ```

- подаване по стойност
- подаване по референция
- const

TODO: Въпроси с отговори

## Цикли и низове (loops and char arrays)

### Задача 1

Да се напише програма, която определя
дали редицата от символи s0, s1, ..., sn−1 (1 ≤ n ≤ 100) е симетрична, т.е.
четена отляво надясно и отдясно наляво е една и съща.

<details>
<summary>Решение. Моля, първо реши задачата преди да прегледаш решението.</summary>

```c++
TODO: Добави решение
```

</details>
<br/>

### Задача 2

Дадена е редицата от символи s0, s1, ..., sn−1 (1 ≤ n ≤
100). Да се напише програма, която извежда отначало всички символи,
които са цифри, след това всички символи, които са малки латински
букви и накрая всички останали символи от редицата, запазвайки реда
им в редицата.

<details>
<summary>Решение. Моля, първо реши задачата преди да прегледаш решението.</summary>

```c++
TODO: Добави решение
```

</details>
<br/>

### Задача 3

Да се напише функция `reverse(s)`, която превръща даден низ в огледалния му образ. Например, низът "`abc"` ще се преобразува до `"cba"`.

<details>
<summary>Решение. Моля, първо реши задачата преди да прегледаш решението.</summary>

```c++
TODO: Добави решение
```

</details>
<br/>

## Динамична памет

### Задача 4

Да се дефинира функция `strduplicate`, която създава
копие на символен низ. Функцията да се грижи за заделянето на памет
за новия низ.

<details>
<summary>Решение. Моля, първо реши задачата преди да прегледаш решението.</summary>

```c++
TODO: Добави решение
```

</details>
<br/>

### Задача 5

Да се дефинира функция, която преобразува положително цяло число в съответния му символен низ и връща така построения
символен низ.

<details>
<summary>Решение. Моля, първо реши задачата преди да прегледаш решението.</summary>

```c++
TODO: Добави решение
```

</details>
<br/>

### Задача 6

Обединение на два символни низа s1 и s2 наричаме всеки символен низ, който съдържа без повторение всички символи на
s1 и s2. Да се дефинира функция, която намира и връща обединението на два символни низа.

<details>
<summary>Решение. Моля, първо реши задачата преди да прегледаш решението.</summary>

```c++
TODO: Добави решение
```

</details>
<br/>

## Динамични масиви

### Задача 7: Четене и Печатане на Динамичен Масив

Напишете програма, която:

1. Пита потребителя за размера на масива.
2. Създава динамичен масив с този размер.
3. Чете от конзолата стойностите на елементите на масива.
4. Отпечатва всички елементи на масива на конзолата.
5. Освобождава заделената памет.

### Задача 8: Намиране на Максимума в Динамичен Масив

Модифицирайте задача 1, като добавите функционалност за намиране на максималния елемент в масива:

1. След като прочетете и отпечатате масива, изчислете кой е максималният елемент в него.
2. Отпечатайте стойността на максималния елемент.

### Задача 9: Обръщане на Елементите на Динамичен Масив

Напишете програма, която:

1. Чете размер и елементите на динамичен масив от конзолата, както в Задача 1.
2. Обръща реда на елементите на масива. (Първият става последен, последният първи, и т.н.)
3. Отпечатва обърнатия масив на конзолата.
4. Освобождава заделената памет.

### Задача 10: Филтриране на Елементите на Динамичен Масив

Създайте програма, която:

1. Чете от конзолата размера на масив и след това елементите му.
2. Пита потребителя за число x.
3. Създава нов динамичен масив, който съдържа само елементите на първия масив, които са по-големи от x.
4. Отпечатва новия масив.
5. Освобождава паметта заделена за двата масива.

### Задача 11: IntArray структура

1. Дефинирайте структурата

```c++
struct IntArray
{
int *arr;
size_t size;
};
```
2. Създайте функция `IntArray createIntArray()`, която създава инстанция на `IntArray` и чете стойности за размера и съдържанието на масива от конзолата.

### Задача 11а: append

Да се дефинира функция `IntArray append (IntArray a, IntArray b)`, създаваща нов масив в динамичната памет, съдържащ последователно елементите на `a` и `b`.

### Задача 11b: mergeSorted
Да се дефинира функция `IntArray mergeSorted (IntArray a, IntArray b)`. `a` и `b` са подредени в нарастващ ред. Функцията да създава нов масив в
динамичната памет, съдържащ всички елементи на `a` и `b` също в нарастващ ред. Например, резултатът от сливането на `[1, 3, 3, 5]` и `[2, 4, 5]` би бил `[1, 2, 3, 3, 4, 5, 5]`. Функцията да обхожда елементите на `a` и `b` точно по веднъж (да работи с линейна сложност).

### Задача 11c: union
Да се дефинира функция `IntArray union (IntArray a, IntArray b)`, създаваща нов масив в динамичната памет, съдържащ всички елементи на `a` и `b` без повторения (обединение на множествата на елементите).

### Задача 11d: intersection
Да се дефинира функция `IntArray intersection (IntArray a, IntArray b)`, създаваща нов масив в динамичната памет, съдържащ елементите, които се съдържат едновременно в `a` и `b` (сечение на множествата на елементите).

### Задача 11e: evens
Да се дефинира функция `IntArray evens (IntArray a)`, създаваща нов масив в динамичната памет, съдържащ само тези елементи на `a`, които са четни числа.