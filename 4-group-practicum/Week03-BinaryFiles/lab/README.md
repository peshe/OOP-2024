# Двоични файлове

## Задача 1 :face_in_clouds:
Напишете програма, която приема име на двоичен файл от командния ред и отпечатва на екрана размера на файла в байтове. Помислете как бихте могли да направите това с помощта на `seek/tell` функциите. Ако такъв файл не съществува или не е подадено име на файл от командния ред, изведете подходящо съобщение.

## Задача 2 :lizard::ocean::fire:	
Напишете структура `Pokemon`, който се състои от:
- име (символен низ с най-много 64 символа)
- тип (изброим тип със следните възможности: NORMAL, FIRE, WATER, GRASS, ELECTRIC, GHOST, FLYING)
- сила (цяло положително число от 10 до 1000)

Създайте функция със сигнатура:
```c++
bool save(const Pokemon* pokemons, std::size_t size, const char* file); 
```
Която запазва масив от покемони в двоичен файл с име `file`. Функцията връща true/false в зависимост от това дали потокът се е отворил успешно или не.

Създайте структура:
```c++
struct PokemonHandler
{
    std::ifstream in;
    std::size_t size;
};
```
Тя трябва да се инициализира чрез функция:
```c++
bool initialize(PokemonHandler& handler, const char* file);
```
Която отваря поток за четене към двоичен файл с име `file` (трябва да бъде предварително създаден и да бъде пълен с покемони). В променливата `size` трябва да бъде запазен броят покемони във файла. Функцията връща true/false в зависимост от това дали потокът се е отворил успешно или не.

Реализирайте функция:
```c++
Pokemon at(PokemonHandler& handler, std::size_t i);
```
Която връща съответния покемон на `i`-та позиция в бинарния файл, към който е отворен поток за четене в `handler`. В debug режим assert-вайте, че индексът не е прекалено голям.

## Задача 3 :framed_picture:
След поредния невзет изпит Радо сериозно започва да се замисля дали ФМИ е за него... Вътрешно той знае за себе си, че не е роден да става програмист, а че неговото призвание е изкуството. Радо е голям почитател на обработването на изображения - да отрязва конкретни части от тях, да ги преоразмерява, да добавя ефекти и т.н. Покажете на Радо, че може да съчетава изкуството с програмирането, като му помогнете да си напише собствена програма, която прави един простичък, но полезен ефект - превръща цветни изображения в черно-бели такива. (*за да звучи по-fancy - от RGB в Grayscale*).

Тошко - най-добрият приятел на Радо, му подсказал, че най-лесно би постигнал това, като обработва `bmp` изображения. Той му обяснил, че това всъщност не са нищо повече от обикновени двоични файлове. Като един истински приятел, Тошко дори разяснил в подробности какви са особеностите на `bmp` изображенията:
- Състоят се от **две** основни части - служебна информация за изображението (**метаданни**) и матрица от пиксели (**практическото съдържание на изображението**)
- Не ни е необходима цялата информация от метаданните; трябват ни само:
    - размерът на файла (**позиция 2**, *4 байта*)
    - позицията, на която започва матрицата от пиксели (**позиция 10**, *4 байта*)
    - брой колони на матрицата от пиксели (**позиция 18**, *4 байта*)
    - брой редове на матрицата от пиксели (**позиция 22**, *4 байта*)
- Всеки пиксел се състои от *3 байта*, по един за всеки от основните три цвята - червено, зелено и синьо (**RGB**) (стойности между **0** и **255**)
- Всеки ред има **padding**, допълващ броя на байтовете на всеки ред да бъде число, делящо се на **4**
- Информацията в padding-a се игнорира при визуализиране на изображението

За да превърне RGB пиксел в Grayscale такъв, Радо попитал своята приятелка Габи, която е специалистка в алгоритмите. За да покаже колко много знае, тя му дала списък със 100 различни алгоритми:
- `Grayscale Value = (R + G + B) / 3`
- `Grayscale Value = (max(R, G, B) + min(R, G, B)) / 2`
- `Grayscale Value = 0.2126 * R + 0.7152 * G + 0.0722 * B`
- `Grayscale Value = 0.30 * R + 0.59 * G + 0.11 * B`
- *списъкът продължава с още 96 алгоритъма...*

Тъй като алгоритмите практически постигат почти един и същи резултат, няма особено голямо значение кой от тях ще избере Радо.

За да бъдете от истинска помощ на Радо, приемете две имена на двоични файлове на изображения в `bmp` формат от командния ред - първият трябва да бъде на съществуващо цветно RGB изображение, а във втория трябва да бъде запазеното конвертираното Grayscale изображение. Използвайки информацията, предоставена ви от Тошко и Габи, реализирайте алгоритъма за конвертиране чрез подходящи структури и функции.

> Подсказка: Използвайте целочислени типове, за които експлицитно знаете размера: `std::uint8_t`, `std::uint32_t` и т.н.

### :warning: Забележки

- Погрижете се за правилната работа с файлове, проверявайте за коректното отваряне на потоците и винаги ги затвярайте след употреба
- Целете се към максимално спазване на чист код
- Не е позволено използването на `std::string`
- Позволено е използването на библиотеките `<cstring>`, `<cassert>`, `<cstddef>` и `<fstream>`
